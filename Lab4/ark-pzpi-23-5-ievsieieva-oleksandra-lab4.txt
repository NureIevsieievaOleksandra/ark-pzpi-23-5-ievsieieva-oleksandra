МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 4 з дисципліни
Аналіз та рефакторинг коду





Виконала:                                                                                     Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Євсєєва Олександра						Сокорчук Ігор Петрович










Харків 2025 
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	21.12.2025	0.1	Створено звіт
 

2 ЗАВДАННЯ

	Отримати практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес логіки, налаштувань, та інтеграцію із серверною частиною. Навчитися використовувати UML для створення діаграм прецедентів та діяльності, а також перевіряти функціональність IoT клієнта через тестування та інтеграцію.
 
3 ОПИС ВИКОНАНОЇ РОБОТИ

	Метою даної роботи є набуття практичних навичок у створенні IoT-клієнта, включаючи проектування його структури та модулів, розробку бізнес логіки та налаштувань, а також перевірку працездатності через тестування та інтеграцію з сервером. Особлива увага приділяється використанню UML-діаграм для моделювання прецедентів та діяльності, що дозволяє наочно представити сценарії взаємодії користувача із системою та послідовність виконання основних дій клієнта.
Подивимось на UML діаграму прецедентів для IoT клієнта (див. рисунок 1). 
Рисунок 1 – UML діаграма прецедентів для IoT клієнта

	Крім того повна UML діаграма діяльності для IoT клієнта наведена в [ДОДАТОК В]. Вона відображає послідовне налаштування WiFi, RGB LED, трекера енергії та температурного сенсора.
	Робота передбачає комплексний підхід до розробки програмного забезпечення IoT-клієнта: від проектування архітектури та бізнес логіки до реалізації функцій налаштування та тестування, що забезпечує ефективну та надійну роботу системи. Увесь код наведено у [ДОДАТОК Б].
1  fun Route.iotWebsocket() {
2      webSocket("/ws") {
3          val iotStatisticsRepository by application.inject<IotStatisticsRepository>()
4
5          WsSessions.sessions += this
6          try {
7              incoming.consumeEach { frame ->
8                  when (frame) {
9                      is Frame.Binary -> {}
10                     is Frame.Close -> {}
11                     is Frame.Ping -> {}
12                     is Frame.Pong -> {}
13                     is Frame.Text -> {
14                         val text = frame.readText()
15                         val stat = Json.decodeFromString(IotStatisticsDto.serializer(), text)
16                         environment.log.info("websocket: $stat")
17                         iotStatisticsRepository.create(stat.toModel())
18                     }
19                 }
20             }
21
22         } finally {
23             WsSessions.sessions -= this
24         }
25     }
26 }

	Цей фрагмент коду реалізує обробку WebSocket-з’єднання в Ktor для маршруту /ws. Коли клієнт підключається, його сесія додається до списку активних сесій, що дозволяє відслідковувати усі підключення. Сервер приймає повідомлення від клієнта в асинхронному режимі та обробляє їх відповідно до типу фрейму: текстові повідомлення перетворюються з JSON у об’єкт IotStatisticsDto, логуються у середовище виконання та зберігаються в базі даних через репозиторій IotStatisticsRepository. Загалом, код забезпечує прийом і збереження статистики IoT у реальному часі через WebSocket.
	Ця програма реалізує управління RGB-світлодіодами на платі ESP32-S3 із використанням WebSocket-з’єднання для отримання команд та передачі статистики про стан пристрою. Під час запуску відбувається ініціалізація апаратних ресурсів, налаштування системного циклу подій та розділу NVS для зберігання параметрів, а також підключення до Wi-Fi мережі. Створюється об’єкт для керування RGB-світлодіодами, який дозволяє змінювати колір та яскравість окремих каналів. Програма встановлює WebSocket-з’єднання з сервером, приймає текстові команди у форматі JSON, перетворює їх на структуру RgbCommand і відповідно змінює параметри світлодіодів. Крім того, кожні десять секунд відправляється JSON з інформацією про час роботи пристрою, причину останнього перезапуску, температуру та енергоспоживання, що дозволяє вести моніторинг стану системи в реальному часі. Програма також підтримує обробку інших типів WebSocket-повідомлень, таких як ping/pong та закриття сесії, забезпечуючи стабільність і надійність роботи.
	Частина коду наведена нижче, увесь код наведено у [ДОДАТОК Б].
1  fn main() -> anyhow::Result<()> {
2      esp_idf_sys::link_patches();
3      esp_idf_svc::log::EspLogger::initialize_default();
4
5      info!("Starting ESP32-S3 RGB WebSocket Controller");
6
7      let peripherals = Peripherals::take()?;
8      let sys_loop = EspSystemEventLoop::take()?;
9      let nvs = EspDefaultNvsPartition::take()?;
10
11     // Налаштування Wi-Fi
12     let mut wifi = BlockingWifi::wrap(
13         EspWifi::new(peripherals.modem, sys_loop.clone(), Some(nvs))?,
14         sys_loop,
15     )?;
16
17     connect_wifi(&mut wifi)?;
18
19     // Налаштування RGB LED з трьома окремими таймерами
20     let mut rgb_led = RgbLed::new(
21         peripherals.ledc.timer0,
22         peripherals.ledc.channel0,
23         peripherals.ledc.channel1,
24         peripherals.ledc.channel2,
25         peripherals.pins.gpio38,
26         peripherals.pins.gpio39,
27         peripherals.pins.gpio40,
28     )?;

	Цей фрагмент коду визначає структури та функції для збору статистики пристрою та обліку енергоспоживання. Структура DeviceStats зберігає основні параметри роботи пристрою, такі як час роботи у мілісекундах, причину останнього перезапуску, температуру в градусах Цельсія, кількість перезапусків через сторожовий таймер та накопичене споживання енергії за день. Функція uptime_ms повертає час роботи пристрою з моменту запуску у мілісекундах, використовуючи системний таймер ESP32. Функція temperature_celsius читає значення температури з датчика і повертає його у вигляді Option<f32>, що дозволяє враховувати можливу відсутність коректного значення. Конструктор EnergyTracker::new створює новий об’єкт для відстеження енергоспоживання, ініціалізуючи останній час оновлення та накопичену енергію. Разом ці компоненти забезпечують збір і облік ключових параметрів стану пристрою та його роботи [ДОДАТОК Б].
1  pub struct DeviceStats {
2      pub uptime_ms: u64,
3      pub last_reset_reason: ResetReason,
4      pub temperature_c: Option<f32>,
5      pub watchdog_resets: u32,
6      pub energy_today_mwh: u32,
7  }
8
9  pub fn uptime_ms() -> u64 {
10     unsafe { esp_timer_get_time() as u64 / 1_000 }
11 }
12
13 pub fn temperature_celsius() -> Option<f32> {
14     unsafe {
15         let mut temp: f32 = 0.0;
16         if temperature_sensor_get_celsius(TEMP_SENSOR, &mut temp) == ESP_OK {
17             Some(temp)
18         } else {
19             None
20         }
21     }
22 }
23
24 impl EnergyTracker {
25     pub fn new(now_ms: u64) -> Self {
26         Self {
27             last_update_ms: now_ms,
28             energy_today_mwh: 0.0,
29         }
30     }
31 }

	У результаті реалізації представлених модулів забезпечується ефективний збір та обробка даних про стан пристрою. Функції вимірювання часу роботи та температури, а також структура для обліку енергоспоживання дозволяють отримувати актуальну статистику в реальному часі. Це створює основу для подальшого контролю та моніторингу пристрою, інтеграції з серверною частиною та реалізації функцій управління системою. 
4 ВИСНОВКИ

	У результаті виконання роботи були отримані практичні навички з розробки IoT клієнта, включаючи проектування його архітектури, бізнес логіки та налаштувань, а також інтеграцію із серверною частиною. Було спроектовано загальну структуру системи з урахуванням модулів обробки даних, мережевих протоколів та управління пристроями. Створено UML діаграму прецедентів, що відображає основні сценарії взаємодії користувача з системою, такі як налаштування параметрів, надсилання даних на сервер та оновлення прошивки. Розроблена бізнес логіка забезпечує роботу з даними пристроїв та їх передачу на сервер, а функції налаштування дозволяють керувати мережею, параметрами підключення та енергоспоживанням. Робота підтвердила ефективність застосування UML та модульного підходу при створенні IoT клієнтів.

 
5 ВИКОРИСТАНІ ДЖЕРЕЛА

1.	ESP-IDF – офіційна документація Espressif. URL: https://docs.espressif.com/projects/esp-idf/en/latest/ (дата звернення: 21.12.2024)
2.	Tungstenite – WebSocket клієнт для Rust. URL: https://github.com/snapview/tungstenite-rs (дата звернення: 21.12.2024)
3.	The Rust Programming Language. URL: https://doc.rust-lang.org/book/ (дата звернення: 21.12.2024)
4.	esp-rs/esp-idf-hal – HAL для ESP32 на Rust. URL: https://github.com/esp-rs/esp-idf-hal (дата звернення: 21.12.2024)
5.	Serde – серіалізація/десеріалізація для Rust. URL: https://serde.rs (дата звернення: 21.12.2024)
 
ДОДАТОК А

Відеозапис: https://youtu.be/JYWOWkWAsso
00:25 - Підключення зовнішнього пристрою 
01:42 - Взаємодія між сервером та IoT пристроєм 
03:35 - Бізнес логіка на сервері 
05:46 - Пояснення роботи датчиків 
11:47 - Демонстрація роботи
 
ДОДАТОК Б

Повністю код можна подивитись за посиланням: https://github.com/NureIevsieievaOleksandra/ark-pzpi-23-5-ievsieieva-oleksandra/tree/main/Lab4/ark-pzpi-23-5-ievsieieva-oleksandra 
  
ДОДАТОК В

	UML діаграма діяльності для IoT клієнта.
 
 
 
Рисунок 2-4 – UML діаграма діяльності для IoT клієнта

