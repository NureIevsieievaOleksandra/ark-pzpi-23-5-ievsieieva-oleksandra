МІНІСТЕРСТВО ОСВІТИ І НАУКИ УКРАЇНИ
ХАРКІВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ РАДІОЕЛЕКТРОНІКИ


КАФЕДРА ПРОГРАМНОЇ ІНЖЕНЕРІЇ




Звіт
з лабораторної роботи № 5 з дисципліни
Аналіз та рефакторинг коду





Виконала:                                                                                     Перевірив:
ст. гр. ПЗПІ-23-5                        				ст. викладач кафедри ПІ
Євсєєва Олександра						Сокорчук Ігор Петрович










Харків 2025 
1 ІСТОРІЯ ЗМІН

№	Дата	Версія звіту	Опис змін та виправлень
1	21.12.2025	0.1	Створено звіт
 

2 ЗАВДАННЯ

	Навчитися розгортати програмну систему, перевіряти її функціональність, виконувати налаштування, а також демонструвати та документувати роботу системи. Використовуючи інструменти для розгортання (наприклад, Docker, Kubernetes, хмарні сервіси), розгорнути серверну частину, веб-клієнт, мобільний клієнт та IoT клієнт. Налаштувати середовище для роботи програмної системи. 
3 ОПИС ВИКОНАНОЇ РОБОТИ

	У процесі розроблення сучасних програмних систем дедалі більшого значення набуває питання автоматизованого розгортання та забезпечення стабільної роботи серверної інфраструктури. Особливо актуальним це є для клієнт-серверних та IoT-орієнтованих систем, які включають декілька взаємопов’язаних компонентів і потребують узгодженої взаємодії між ними.
	Подивимось як повинна виглядати схема компонентів програмної системи (див. рисунок 1).
 
Рисунок 1 – Схеми взаємодії компонентів програмної системи

	Одразу розглянемо і діаграму структури даних, яка залишилась незмінної із попередніх робіт (див. рисунок 2).
 
Рисунок 2 – Діаграма структури даних

	З метою спрощення процесу розгортання, підвищення відтворюваності середовища виконання та зменшення залежності від конкретної платформи у даній роботі застосовано технологію контейнеризації Docker.
	Подана конфігурація призначена для контейнеризації серверної частини програмної системи керування освітленням із використанням технології Docker. Вона складається з файлу збірки Dockerfile та файлу оркестрації docker compose, які забезпечують автоматизоване розгортання серверного застосунку та бази даних.
	Dockerfile описує процес побудови контейнера серверного застосунку у два етапи. На першому етапі використовується базовий образ із встановленим Gradle та JDK 21, який призначений для компіляції та збірки застосунку. Вихідний код копіюється у робочу директорію контейнера, після чого виконується збірка проєкту з формуванням виконуваного JAR-файлу. Такий підхід дозволяє ізолювати середовище збірки та не включати зайві інструменти у фінальний контейнер [ДОДАТОК Б].
1  FROM gradle:9.1.0-jdk21 AS builder
2  
3  WORKDIR /app
4  COPY . .
5  RUN gradle build --no-daemon
6  #RUN gradle build --no-daemon --stacktrace --info
7  
8  FROM eclipse-temurin:21-jre
9  WORKDIR /app
10 COPY --from=builder /app/build/libs/*.jar app.jar
11 EXPOSE 8080
12 ENTRYPOINT ["java", "-jar", "app.jar"]

	Другий етап Dockerfile використовує полегшений образ з Java Runtime Environment, що забезпечує лише виконання вже зібраного застосунку. До контейнера копіюється згенерований JAR-файл, відкривається мережевий порт, на якому працює сервер, після чого застосунок запускається за допомогою віртуальної машини Java. Двоетапна збірка дозволяє зменшити розмір фінального образу та підвищити безпеку і продуктивність розгортання.
	Файл docker compose визначає багатоконтейнерну конфігурацію системи та описує взаємодію між серверним застосунком і базою даних. У конфігурації визначено сервіс серверного API, який збирається з Dockerfile та запускається у власному контейнері. Для забезпечення доступу до бази даних сервер отримує параметри підключення через змінні середовища, що дозволяє уникнути жорсткого задання конфігураційних значень у коді застосунку [ДОДАТОК Б].
1  services:
2    api:
3      build: .
4      container_name: smartLight
5      ports:
6        - "8080:8080"
7      environment:
8        DB_URL: jdbc:postgresql://db:5432/light
9        DB_USER: light
10       DB_PASSWORD: Secret1
11     depends_on:
12       db:
13         condition: service_healthy
14   db:
15     image: postgres:18
16     container_name: postgres-db
17     volumes:
18       - ./db/init.sql:/docker-entrypoint-initdb.d/init.sql
19     environment:
20       POSTGRES_DB: light
21       POSTGRES_USER: light
22       POSTGRES_PASSWORD: Secret1
23     ports:
24       - "5432:5432"
25     healthcheck:
26       test: [ "CMD-SHELL", "pg_isready -U light" ]
27       interval: 1s
28
29 volumes:
30   pgdata:

	Таким чином, використання Docker та docker compose забезпечує відтворюване, ізольоване та зручне розгортання програмної системи, спрощує процес тестування і запуску на різних середовищах та підвищує загальну надійність серверної інфраструктури.
	Але бізнес логіка процесів не змінилася [ДОДАТОК Б]. 
1      override suspend fun getMathExpectationR(): Pair<Double, Double> =
2          suspendTransaction {
3              val meanR = EventTable.r.avg()
4              val meanRSq = (EventTable.r * EventTable.r).avg()
5
6              EventTable.slice(meanR, meanRSq)
7                  .selectAll()
8                  .singleOrNull()
9                  ?.let {
10                     val mean = (it[meanR] as? Number)?.toDouble() ?: 0.0
11                     val variance = ((it[meanRSq] as? Number)?.toDouble() ?: 0.0) - mean * mean
12                     mean to variance
13                 } ?: (0.0 to 0.0)
14         }

	У процесі виконання функції спочатку формується агрегатний запит для знаходження середнього значення компоненти R. Паралельно з цим обчислюється середнє значення квадратів цієї компоненти, що є необхідним для подальшого визначення дисперсії. Обидва агрегатні значення отримуються безпосередньо засобами SQL через ORM Exposed, що зменшує обсяг передаваних даних та підвищує ефективність обчислень.
	Після виконання запиту результати зчитуються з єдиного рядка вибірки. Математичне сподівання визначається як середнє арифметичне значень компоненти R. Дисперсія обчислюється за класичною формулою як різниця між середнім значенням квадратів та квадратом середнього значення. Такий підхід відповідає статистичному означенню дисперсії випадкової величини.
	У разі відсутності даних у таблиці або неможливості отримання результатів функція повертає нульові значення, що запобігає виникненню помилок під час подальшої обробки даних.
1      override suspend fun getByColors(): List<ColorContest> = suspendTransaction {
2          EventTable
3              .select(
4                  EventTable.r,
5                  EventTable.g,
6                  EventTable.b,
7                  EventTable.id.count()
8              )
9              .groupBy(
10                 EventTable.r,
11                 EventTable.g,
12                 EventTable.b
13             )
14             .orderBy(EventTable.id.count(), SortOrder.DESC)
15             .limit(10)
16             .map {
17                 ColorContest(
18                     r = it[EventTable.r],
19                     g = it[EventTable.g],
20                     b = it[EventTable.b],
21                     count = it[EventTable.id.count()]
22                 )
23             }
24     }

	Цей фрагмент коду є реалізацією функції getByColors, яка працює як запит до бази даних з використанням бібліотеки Exposed у Kotlin для отримання статистики кольорів з таблиці EventTable. Функція асинхронна (suspend) і виконується всередині транзакції suspendTransaction. Використовується метод select для отримання з таблиці EventTable колонок r, g, b (компоненти кольору) та підрахунку кількості записів (id.count()) для кожної комбінації кольорів.
	Результат перетворюється у список об’єктів ColorContest, де кожен об’єкт містить поля r, g, b та count (кількість повторень конкретного кольору).
1              let uptime = uptime_ms();
2              info!("Uptime: {uptime} ms");
3              let last_reset_reason = last_reset_reason();
4              info!("Last reset reason: {last_reset_reason:?}");
5              let temperature = temperature_celsius();
6              match temperature {
7                  None => {}
8                  Some(value) => {
9                      info!("Temperature: {value:?}");
10                 }
11             }
12
13             let stats_json = serde_json::json!({
14                 "id": id,
15                 "uptime": uptime,
16                 "last_reset": format!("{:?}", last_reset_reason),
17                 "energy": energy_tracker,
18                 "temperature": temperature,
19             });

	Спочатку отримується час роботи системи в мілісекундах за допомогою функції uptime_ms() та логуються ці дані. Потім визначається причина останнього перезапуску через last_reset_reason() і також виводиться у лог. Температура системи вимірюється функцією temperature_celsius(), яка повертає Option<f32>; якщо значення доступне, воно виводиться у лог. Наприкінці створюється JSON-об’єкт, який містить ідентифікатор пристрою, час роботи, причину останнього перезапуску, показники енергоспоживання (energy_tracker) та температуру, що дозволяє централізовано збирати і передавати ключові показники стану системи.
  
4 ВИСНОВКИ

	У ході виконання лабораторної роботи №5 було розглянуто розгортатання програмної системи, перевірку її функціональності, виконання налаштування параметрів серверної частини, клієнтських застосунків та мережевих протоколів для коректної роботи системи.
 
5 ВИКОРИСТАНІ ДЖЕРЕЛА

1.	Ktor – офіційна документація: Docker
URL: https://ktor.io/docs/docker.html (дата звернення: 21.12.2025)
2.	Ktor – офіційна документація: Docker Compose
URL: https://ktor.io/docs/docker-compose.html (дата звернення: 21.12.2025)
3.	Документація Docker – Оркестрація та використання контейнерів
URL: https://docs.docker.com/guides/orchestration/ (дата звернення: 21.12.2025)
4.	Serde JSON – офіційна документація (crate сторінка)
URL: https://docs.rs/serde_json/latest/serde_json/ (дата звернення: 21.12.2025)
 
ДОДАТОК А

Відеозапис: https://youtu.be/f6ygbv2N470
00:46 - Пояснення Dockerfile 
02:23 - Пояснення Docker compose 
04:16 - Резервна копія БД 
05:33 - Демонстрація Docker desktop 
07:12 - Демонстрація бізнес логіки у Postman

 
ДОДАТОК Б

Повністю код можна подивитись за посиланням: https://github.com/NureIevsieievaOleksandra/ark-pzpi-23-5-ievsieieva-oleksandra/tree/main/Lab5/ark-pzpi-23-5-ievsieieva-oleksandra 
 

